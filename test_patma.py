import array
import collections.abc
import dataclasses
import sys

from patma import *


def checks(pat, x):
    """Compare pat.match(x) the code generated by pat.translate().

    If they match, return whatever pat.match() returned.
    """
    match = pat.match(x)
    ns = {"X": x,
          "Sequence": collections.abc.Sequence,
          "Mapping": collections.abc.Mapping,
          "_Nope": object(),  # Used for "attribute doesn't exist"
          __name__: sys.modules[__name__],
          }
    res = eval(pat.translate("X"), ns)
    if "__builtins__" in ns:
        del ns["__builtins__"]  # We don't need this for the comparison
    if not res:
        assert match is None
        return match
    assert match is not None
    for key, value in match.items():
        assert key in ns
        assert ns[key] == value
        assert type(ns[key]) == type(value)
    return match


@dataclasses.dataclass
class MyClass:
    x: int
    y: str

    @staticmethod
    def __match__(target):
        if not isinstance(target, MyClass):
            return None
        return target

    __pos_match_fields__ = ('x', 'y')


def test_constant_pattern():
    # case 42:
    pat = ConstantPattern(42)
    assert checks(pat, 42) == {}
    assert checks(pat, 0) is None
    assert checks(pat, 42.0) is None
    assert checks(pat, "42") is None


def test_constant_float_pattern():
    # case 42.0:
    pat = ConstantPattern(42.0)
    assert checks(pat, 42.0) == {}
    assert checks(pat, 42) == {}
    assert checks(pat, 0.0) is None
    assert checks(pat, 0) is None


def test_alternatives_pattern():
    # case 1|2|3:
    pat = AlternativesPattern([ConstantPattern(i) for i in [1, 2, 3]])
    assert checks(pat, 1) == {}
    assert checks(pat, 2) == {}
    assert checks(pat, 3) == {}
    assert checks(pat, 3.0) is None
    assert checks(pat, 0) is None
    assert checks(pat, 4) is None
    assert checks(pat, "1") is None


def test_fancy_alternatives_pattern():
    # case [1, 2] | [3, 4]:
    pat = AlternativesPattern(
        [
            SequencePattern([ConstantPattern(1), ConstantPattern(2)]),
            SequencePattern([ConstantPattern(3), ConstantPattern(4)]),
        ]
    )
    assert checks(pat, [1, 2]) == {}
    assert checks(pat, [3, 4]) == {}
    assert checks(pat, 42) is None
    assert checks(pat, [2, 3]) is None
    assert checks(pat, [1, 2, 3]) is None
    assert checks(pat, [1, 2.0]) is None


def test_variable_pattern():
    # case x:
    pat = VariablePattern("x")
    assert checks(pat, 42) == {"x": 42}
    assert checks(pat, (1, 2)) == {"x": (1, 2)}
    assert checks(pat, None) == {"x": None}


def test_annotated_pattern():
    # case (x: int):
    pat = AnnotatedPattern(VariablePattern("x"), int)
    assert checks(pat, 42) == {"x": 42}
    assert checks(pat, "hello") is None


def test_int_matches_float():
    # case (x: float):  # Should match int
    pat = AnnotatedPattern(VariablePattern("x"), float)
    assert pat.match(42) == {"x": 42}  # TODO: translate should assume int <: float
    assert type(pat.match(42)["x"]) == int  # TODO: translate ditto


def test_float_doesnt_match_int():
    # case (x: int):  # Shouldn't match 1.0
    pat = AnnotatedPattern(VariablePattern("x"), int)
    assert checks(pat, 1.0) is None


def test_sequence_pattern():
    # case (x, y, z):
    pat = SequencePattern([VariablePattern(s) for s in "xyz"])
    assert checks(pat, (1, 2, 3)) == {"x": 1, "y": 2, "z": 3}
    assert checks(pat, (1, 2)) is None
    assert checks(pat, (1, 2, 3, 4)) is None
    assert checks(pat, 123) is None
    # Check that character/byte strings don't match sequences
    assert pat.match("abc") is None  # TODO: translate should disallow strings
    assert pat.match(b"abc") is None  # TODO: translate ditto
    assert pat.match(array.array("b", b"abc")) is None  # TODO: translate ditto
    ## assert checks(pat, memoryview(b'abc')) is None
    ## assert checks(pat, bytearray(b'abc')) is None


def test_mapping_pattern():
    # case {"x": x, "y": "z": z}:
    pat = MappingPattern({"x": VariablePattern("x"),
                          "y": ConstantPattern("y"),
                          "z": VariablePattern("z")})
    assert checks(pat, {"x": "x", "y": "y", "z": "z"}) == {"x": "x", "z": "z"}
    assert checks(pat, {"x": "x", "y": "y", "z": "z", "a": "a"}) == {"x": "x", "z": "z"}
    assert checks(pat, {"x": "x", "y": "yy", "z": "z", "a": "a"}) is None
    assert checks(pat, {"x": "x", "y": "y"}) is None


def test_instance_pattern():
    # case MyClass(xx: int, y='hello'):
    vxx = AnnotatedPattern(VariablePattern("xx"), int)
    hello = ConstantPattern("hello")
    pat = InstancePattern(MyClass, [vxx], {"y": hello})
    assert checks(pat, MyClass(42, "hello")) == {"xx": 42}


def test_walrus_pattern():
    # case x := (p, q):
    pat = WalrusPattern("x", SequencePattern([VariablePattern(s) for s in "pq"]))
    assert checks(pat, (1, 2)) == {"p": 1, "q": 2, "x": (1, 2)}
    assert checks(pat, [1, 2]) == {"p": 1, "q": 2, "x": [1, 2]}
    assert checks(pat, 12) is None
    assert checks(pat, (1, 2, 3)) is None
